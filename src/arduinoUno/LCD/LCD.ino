#include <SoftwareSerial.h>   //Bluetooth serial library
#include <Adafruit_GFX.h>     // Core graphics library
#include <Adafruit_TFTLCD.h>  // Hardware-specific library
#include <TouchScreen.h>      //Touchscreen LCD library

#define LCD_CS A3  // Chip Select
#define LCD_CD A2  // Command/Data
#define LCD_WR A1  // LCD Write
#define LCD_RD A0  // LCD Read

#define YP A3  //Y+ to A10
#define XM A2  //X- to A11
#define YM 23  //Y- to D9
#define XP 22  //X+ to D8

// Coordinate system for touchscreen
#define TS_MINX 110
#define TS_MINY 80
#define TS_MAXX 900
#define TS_MAXY 940

// Pressure values for touchscreen
#define MINPRESSURE 50
#define MAXPRESSURE 1000

// Common colours:
#define BLACK 0x0000
#define WHITE 0xFFFF

// Default theme colours:
#define TEAL 0x028C
#define LIGHTBROWN 0xDD0D
#define GREEN 0x4305
#define MUSTARD 0xED67
#define DARKGRAY 0x41E8
#define PINK 0xEAAA
#define PURPLE 0x398A

// Dark theme colours:
#define DARK_BLUEGRAY 0x2947
#define DARK_BROWN 0x3944
#define DARK_GREEN 0x01A0
#define DARK_TAN 0xC4A9
#define DARK_LIGHTBROWN 0xC448
#define DARK_BROWNWHITE 0xE612
#define DARK_PINK 0x4806
#define DARK_PURPLE 0x1885

// Main screen buttons
#define MAIN_BUTTON_X 230
#define MAIN_BUTTON_Y 235

// Mode screen buttons
#define MODE_BUTTON_X 230
#define MODE_BUTTON_Y 75

// Game screen buttons
#define GAME_BUTTON_X 200
#define GAME_BUTTON_Y 75

// Promotion screen buttons
#define PROMOTION_COMMON_X 360
#define PROMOTION_RARE_X 90
#define PROMOTION_Y 100
#define ICON_SIZE 90

// Confirmation screen buttons
#define YES_NO_X 120
#define YES_NO_Y 80

// End/error screen buttons
#define OK_BUTTON_X 100
#define OK_BUTTON_Y 80
#define TERMINATION_TEXT_Y 100

// Theme button
#define THEME_BUTTON_X 70
#define THEME_BUTTON_Y 70

#define TOUCH_DELAY 50

SoftwareSerial BTserial(10, 11); //TX, RX

Adafruit_TFTLCD tft(LCD_CS, LCD_CD, LCD_WR, LCD_RD, A4);
TouchScreen ts = TouchScreen(XP, YP, XM, YM, 290);

int BACKGROUND_COLOUR, PRIMARY_COLOUR, SECONDARY_COLOUR, TERTIARY_COLOUR, QUATERNARY_COLOUR, BORDER_COLOUR, TEXT_COLOUR_1, TEXT_COLOUR_2, TEXT_COLOUR_3, HIGHLIGHT_COLOUR, THEME_BUTTON_COLOUR;

//[topLeftX, topLeftY] for each button
int mainScreenBounds[2][2] = {};
int modeSelectScreenBounds[3][2] = {};
int gameScreenBounds[3][2] = {};
int okButtonBounds[1][2] = {};
int themeButtonBounds[1][2] = {};
int promotionScreenBounds[4][2] = {};
int confirmationScreenBounds[2][2] = {};

char* currentTheme = "light";
int currentScreen = 0; //0 for main screen, 1 for mode select screen, 2 for game screen, 3 for promotion screen, 4 for termination screen, 5 for error screen, 6 for confirmation screen
int currentUserMode = 1; //0 for beginner mode, 1 for normal mode, 2 for engine mode
char currentGameState = 'n'; //n for not active, s for started (game active), b for black resign, w for white resign, d for draw by agreement
char currentFen[100] = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"; //Starting position
double time = 0.0;
char inputStr[100] = "";
char* currentEngineMove = "N/A";
char selectedPromotion = 'Q';

// Global variable initializations
const int numRows = 8;
const int numCols = 8;

int turns = 1;
GameMode gameMode = BEGINNER_MODE;
GameState gameState = INIT_GAME;
GameCommand gameCommand = NO_ACTION;

Colour whoseTurn = WHITE;
bool promoting = false;

// Start command from LCD
int gameStartPB = 0;

Square *liftedSquare;
Square *placed;

int clk = A5;
int cs = A8;
int anodes[8] = {46,47,48,49,50,51,52,53};
int cathodes[8] = {38,39,40,41,42,43,44,45};
int hallRx[8] = {A13,A11,A9,A6,2,4,6,8};
int hallTx[8] = {A14,A12,A10,A7,3,5,7,9};

int rawStates[8][8] = {{0, 0, 0, 0, 0, 0, 0, 0},
                       {0, 0, 0, 0, 0, 0, 0, 0},
                       {0, 0, 0, 0, 0, 0, 0, 0},
                       {0, 0, 0, 0, 0, 0, 0, 0},
                       {0, 0, 0, 0, 0, 0, 0, 0},
                       {0, 0, 0, 0, 0, 0, 0, 0},
                       {0, 0, 0, 0, 0, 0, 0, 0},
                       {0, 0, 0, 0, 0, 0, 0, 0}};


Square currentBoard[numRows][numCols];
Square oldBoard[numRows][numCols];

// Bitmap icons
// 'brush', 60x60px
const unsigned char epdBitmapBrush [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xfe, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf8, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x83, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc1, 0xff, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xe0, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x7f, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xf8, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x1f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x06, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xf8, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x0f, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x87, 0xc0, 0x00, 0x00, 0x00, 
	0x03, 0xff, 0xff, 0xc3, 0x80, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xc3, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x1f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x1f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x1f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x3f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'knight', 90x90px
const unsigned char epdBitmapKnight [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 
	0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 
	0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xfe, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 
	0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 
	0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xfc, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 
	0xf8, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0xff, 0xff, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xf0, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 
	0xe0, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0xff, 0xff, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0x81, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
	0x81, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x01, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'bishop', 90x90px
const unsigned char epdBitmapBishop [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x19, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x79, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xf9, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf9, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf9, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xf9, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xfd, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'queen', 90x90px
const unsigned char epdBitmapQueen [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x7f, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x3f, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'rook', 90x90px
const unsigned char epdBitmapRook [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xc1, 0xff, 0xe0, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xc1, 0xff, 0xe0, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0xe0, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0xe0, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0xe0, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

enum GameMode : char
{
    BEGINNER_MODE = 'B',
    NORMAL_MODE = 'N',
    ENGINE_MODE = 'E',
    NO_MODE = 'M'
};

enum GameState : char
{
    INIT_GAME = 'i',
    PLAY_GAME = 'p',
    RESET_GAME = 'r',
    WAIT_PICK = 'w',
    PIECE_LIFTED = 'l',
    REMOVE_PIECE = 'x',
    PROMOTING = 'P',
    VALID_MOVE = 'v',
    INVALID_MOVE = 'n',
};

enum GameCommand : char
{
    PROMOTE_QUEEN = 'Q',
    PROMOTE_ROOK = 'R',
    PROMOTE_BISHOP = 'B',
    PROMOTE_KNIGHT = 'K',
    DRAW_ACTION = 'd',
    RESIGN_ACTION = 'q',
    RESET_ACTION = 'r',
    END_GAME = 'e',
    NO_ACTION = '.'
};

// Enum to represent the different types of chess pieces
enum PieceType : char
{
    NO_PIECE = '0',
    PAWN = 'P',
    KNIGHT = 'N',
    BISHOP = 'B',
    ROOK = 'R',
    QUEEN = 'Q',
    KING = 'K'
};

// BLACK is 32 because P + 32 = p
// Use this to convert to FEN string
enum Colour
{
    WHITE = 0,
    BLACK = 32,
    NO_COLOUR = 64
};

// Structure to represent a chess piece
// Members: PieceType, Colour
// Default NO_PIECE, NO_COLOUR
struct Piece
{
    PieceType type;
    Colour colour;

    bool operator==(const Piece &p) const
    {
        return (type == p.type && colour == p.colour);
    }

    Piece() : type(PieceType::NO_PIECE), colour(Colour::NO_COLOUR) {}
    Piece(PieceType pieceType, Colour colourType) : type(pieceType), colour(colourType) {}
};

struct Square
{
    Piece piece;
    int row;
    int col;

    bool operator==(const Square &s) const
    {
        return (piece == s.piece && row == s.row && col == s.col);
    }

    Square() : piece(Piece()), row(0), col(0) {}
    Square(int r, int c) : piece(Piece{}), row(r), col(c) {}
    Square(Piece piece, int r, int c) : piece(piece), row(r), col(c) {}
    Square(PieceType type, Colour colour, int r, int c) : piece(Piece{type, colour}), row(r), col(c) {}
};

void setup() {
	Serial.begin(9600);
	BTserial.begin(9600);
	tft.begin(tft.readID());
	changeTheme(currentTheme);
	tft.setRotation(1);
	makeMainScreen();
}

void loop() {
	// Touchscreen points
	TSPoint p = ts.getPoint();
	pinMode(XM, OUTPUT);
	pinMode(YP, OUTPUT);
	if (p.z > MINPRESSURE && p.z < MAXPRESSURE) {
		p.x = map(p.x, TS_MINY, TS_MAXY, 0, tft.height());
		p.y = map(p.y, TS_MINX, TS_MAXX, 0, tft.width());
		int x = p.y;
		int y = tft.height() - p.x;
		handleTouch(x, y);
	}
	btComm();
}

void handleTouch(int x, int y) {
	//Start button (main screen or mode select screen)
	if ((currentScreen == 0 || currentScreen == 1) && (x > mainScreenBounds[0][0] && x < (mainScreenBounds[0][0] + MAIN_BUTTON_X) && y > mainScreenBounds[0][1] && y < (mainScreenBounds[0][1] + MAIN_BUTTON_Y))) {
		startGameButton();
	}
	
	//Mode button (main screen)
	if (currentScreen == 0 && (x > mainScreenBounds[1][0] && x < (mainScreenBounds[1][0] + MAIN_BUTTON_X) && y > mainScreenBounds[1][1] && y < (mainScreenBounds[1][1] + MAIN_BUTTON_Y))) {
		selectModeButton();
	}

	//Beginner mode button (mode select screen)
	if (currentScreen == 1 && ((millis() - time) > TOUCH_DELAY) && (x > modeSelectScreenBounds[0][0] && x < (modeSelectScreenBounds[0][0] + MODE_BUTTON_X) && y > modeSelectScreenBounds[0][1] && y < (modeSelectScreenBounds[0][1] + MODE_BUTTON_Y))) {
		selectMode(0);
	}

	//Normal mode button (mode select screen)
	if (currentScreen == 1 && ((millis() - time) > TOUCH_DELAY) && (x > modeSelectScreenBounds[1][0] && x < (modeSelectScreenBounds[1][0] + MODE_BUTTON_X) && y > modeSelectScreenBounds[1][1] && y < (modeSelectScreenBounds[1][1] + MODE_BUTTON_Y))) {
		selectMode(1);
	}

	//Engine mode button (mode select screen)
	if (currentScreen == 1 && ((millis() - time) > TOUCH_DELAY) && (x > modeSelectScreenBounds[2][0] && x < (modeSelectScreenBounds[2][0] + MODE_BUTTON_X) && y > modeSelectScreenBounds[2][1] && y < (modeSelectScreenBounds[2][1] + MODE_BUTTON_Y))) {
		selectMode(2);
	}

	//White resign button (game screen)
	if (currentScreen == 2 && (x > gameScreenBounds[0][0] && x < (gameScreenBounds[0][0] + GAME_BUTTON_X) && y > gameScreenBounds[0][1] && (y < gameScreenBounds[0][1] + GAME_BUTTON_Y))) {
		resignWhiteButton();
	}

	//Draw button (game screen)
	if (currentScreen == 2 && (x > gameScreenBounds[1][0] && x < (gameScreenBounds[1][0] + GAME_BUTTON_X) && y > gameScreenBounds[1][1] && (y < gameScreenBounds[1][1] + GAME_BUTTON_Y))) {
		drawButton();
	}

	//Black resign button (game screen)
	if (currentScreen == 2 && (x > gameScreenBounds[2][0] && x < (gameScreenBounds[2][0] + GAME_BUTTON_X) && y > gameScreenBounds[2][1] && (y < gameScreenBounds[2][1] + GAME_BUTTON_Y))) {
		resignBlackButton();
	}

	//Queen button (promotion screen)
	if (currentScreen == 3 && (x > promotionScreenBounds[0][0] && x < (promotionScreenBounds[0][0] + PROMOTION_COMMON_X) && y > promotionScreenBounds[0][1] && (y < promotionScreenBounds[0][1] + PROMOTION_Y))) {
		selectedPromotion = 'Q';
    	promotionButton(selectedPromotion);
	}

	//Rook button (promotion screen)
	if (currentScreen == 3 && (x > promotionScreenBounds[1][0] && x < (promotionScreenBounds[1][0] + PROMOTION_RARE_X) && y > promotionScreenBounds[1][1] && (y < promotionScreenBounds[1][1] + PROMOTION_Y))) {
		currentScreen = 6;
		makeConfirmationScreen('R');
	}

	//Bishop button (promotion screen)
	if (currentScreen == 3 && (x > promotionScreenBounds[2][0] && x < (promotionScreenBounds[2][0] + PROMOTION_RARE_X) && y > promotionScreenBounds[2][1] && (y < promotionScreenBounds[2][1] + PROMOTION_Y))) {
		currentScreen = 6;
    	makeConfirmationScreen('B');
	}

	//Knight button (promotion screen)
	if (currentScreen == 3 && (x > promotionScreenBounds[3][0] && x < (promotionScreenBounds[3][0] + PROMOTION_COMMON_X) && y > promotionScreenBounds[3][1] && (y < promotionScreenBounds[3][1] + PROMOTION_Y))) {
		currentScreen = 6;
    	makeConfirmationScreen('N');
	}

	//OK button (end screen)
	if (currentScreen == 4 && (x > okButtonBounds[0][0] && x < (okButtonBounds[0][0] + OK_BUTTON_X) && y > okButtonBounds[0][1] && (y < okButtonBounds[0][1] + OK_BUTTON_Y))) {
		okButton();
	}

	//Theme button
	if ((currentScreen != 3 && currentScreen != 5) && (x > themeButtonBounds[0][0] && x < (themeButtonBounds[0][0] + THEME_BUTTON_X) && y > themeButtonBounds[0][1] && (y < themeButtonBounds[0][1] + THEME_BUTTON_Y))) {
		themeButton();
    	//makePromotionScreen();
	}	

	//Yes confirmation
	if (currentScreen == 6 && ((millis() - time) > TOUCH_DELAY) && (x > confirmationScreenBounds[0][0] && x < (confirmationScreenBounds[0][0] + YES_NO_X) && y > confirmationScreenBounds[0][1] && (y < confirmationScreenBounds[0][1] + YES_NO_Y))) {
		promotionButton(selectedPromotion);
	}

	//No confirmation
	if (currentScreen == 6 && ((millis() - time) > TOUCH_DELAY) && (x > confirmationScreenBounds[1][0] && x < (confirmationScreenBounds[1][0] + YES_NO_X) && y > confirmationScreenBounds[1][1] && (y < confirmationScreenBounds[1][1] + YES_NO_Y))) {
		makePromotionScreen();
	}
}

void btComm() {
	// Receive data from external device
	if (BTserial.available()) {
		char c = BTserial.read(); // Comes in form "FEN@code@code\r\n"
		if (c == -1) {
			Serial.println("nothing");
			return;
		}
		if (c == '\n') {
			parseWebPayload(inputStr);
			memset(inputStr, 0, 10);
		}
		else if (c == '\r') {
			;			
		}
		else {
			strncat(inputStr, &c, 1);
		}
	}

	// Send data to external device
	if (Serial.available()) {
		BTserial.write(Serial.read());
	}
}

void makeMainScreen() {
	tft.fillScreen(BACKGROUND_COLOUR);
	int paddingX = 5;
	int paddingY = 5;
	int x = paddingX;
	int y = 2*paddingY + THEME_BUTTON_Y;

	tft.fillRect(x, y, MAIN_BUTTON_X + paddingX, MAIN_BUTTON_Y, SECONDARY_COLOUR);
	tft.drawRect(x, y, MAIN_BUTTON_X + paddingX, MAIN_BUTTON_Y, BORDER_COLOUR);
	mainScreenBounds[0][0] = x;
	mainScreenBounds[0][1] = y;

	tft.fillRect(3*paddingX + MAIN_BUTTON_X, y, MAIN_BUTTON_X, MAIN_BUTTON_Y, PRIMARY_COLOUR);
	tft.drawRect(3*paddingX + MAIN_BUTTON_X, y, MAIN_BUTTON_X, MAIN_BUTTON_Y, BORDER_COLOUR);
	mainScreenBounds[1][0] = 3*paddingX + MAIN_BUTTON_X;
	mainScreenBounds[1][1] = y;

	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(6);
	int textInset = (MAIN_BUTTON_X - getPixelWidth("Start", 6)) / 2;
	tft.setCursor(mainScreenBounds[0][0] + textInset, mainScreenBounds[0][1] + 40);
	tft.println("Start");

	textInset = (MAIN_BUTTON_X - getPixelWidth("Game", 6)) / 2;
	tft.setCursor(mainScreenBounds[0][0] + textInset, tft.getCursorY() + paddingY);
	tft.println("Game");

	drawStartMode();
	
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(6);
	textInset = (MAIN_BUTTON_X - getPixelWidth("Select", 6)) / 2;
	tft.setCursor(mainScreenBounds[1][0] + textInset + 3, mainScreenBounds[1][1] + 40);
	tft.println("Select");

	textInset = (MAIN_BUTTON_X - getPixelWidth("User", 6)) / 2;
	tft.setCursor(mainScreenBounds[1][0] + textInset, tft.getCursorY() + paddingY);
	tft.println("User");
	
	textInset = (MAIN_BUTTON_X - getPixelWidth("Mode", 6)) / 2;
	tft.setCursor(mainScreenBounds[1][0] + textInset, tft.getCursorY() + paddingY);
	tft.println("Mode");

	tft.setCursor(5, 18);
	tft.setTextColor(TEXT_COLOUR_2);
	tft.setTextSize(5);
	tft.print("Chess Connect");

	makeThemeButton();
}

void makeModeSelectScreen() {
	int paddingX = 5;
	int paddingY = 5;
	int x = 3*paddingX + MAIN_BUTTON_X;
	int y = 3*paddingY + THEME_BUTTON_Y + MODE_BUTTON_Y;
	tft.fillRect(x, 2*paddingY + THEME_BUTTON_Y, MODE_BUTTON_X, 3*MODE_BUTTON_Y + 2*paddingY, BACKGROUND_COLOUR);

	if (currentUserMode == 0) {
		// Highlight Beginner
		tft.fillRect(x, y - MODE_BUTTON_Y - 5, MODE_BUTTON_X, MODE_BUTTON_Y, HIGHLIGHT_COLOUR); 
		tft.drawRect(x, y - MODE_BUTTON_Y - 5, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[0][0] = x;
		modeSelectScreenBounds[0][1] = y - MODE_BUTTON_Y - 5;
		int textInset = (MAIN_BUTTON_X - getPixelWidth("Beginner", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[0][0] + textInset, modeSelectScreenBounds[0][1] + 24);
		tft.setTextColor(TEXT_COLOUR_3);
		tft.setTextSize(4);
		tft.print("Beginner");
		
		tft.fillRect(x, y, MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR); 
		tft.drawRect(x, y, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[1][0] = x;
		modeSelectScreenBounds[1][1] = y;
		textInset = (MAIN_BUTTON_X - getPixelWidth("Normal", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[1][0] + textInset, modeSelectScreenBounds[1][1] + 24);
		tft.setTextColor(TEXT_COLOUR_1);
		tft.setTextSize(4);
		tft.print("Normal");
		
		tft.fillRect(x, y + MODE_BUTTON_Y + 5, MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR); 
		tft.drawRect(x, y + MODE_BUTTON_Y + 5, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[2][0] = x;
		modeSelectScreenBounds[2][1] = y + MODE_BUTTON_Y + 5;
		textInset = (MAIN_BUTTON_X - getPixelWidth("Engine", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[2][0] + textInset, modeSelectScreenBounds[2][1] + 24);
		tft.setTextColor(TEXT_COLOUR_1);
		tft.setTextSize(4);
		tft.print("Engine");
	}
	else if (currentUserMode == 1) {
		// Highlight Normal
		tft.fillRect(x, y - MODE_BUTTON_Y - 5, MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR); 
		tft.drawRect(x, y - MODE_BUTTON_Y - 5, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[0][0] = x;
		modeSelectScreenBounds[0][1] = y - MODE_BUTTON_Y - 5;
		int textInset = (MAIN_BUTTON_X - getPixelWidth("Beginner", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[0][0] + textInset, modeSelectScreenBounds[0][1] + 24);
		tft.setTextColor(TEXT_COLOUR_1);
		tft.setTextSize(4);
		tft.print("Beginner");
		
		tft.fillRect(x, y, MODE_BUTTON_X, MODE_BUTTON_Y, HIGHLIGHT_COLOUR);
		tft.drawRect(x, y, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[1][0] = x;
		modeSelectScreenBounds[1][1] = y;
		textInset = (MAIN_BUTTON_X - getPixelWidth("Normal", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[1][0] + textInset, modeSelectScreenBounds[1][1] + 24);
		tft.setTextColor(TEXT_COLOUR_3);
		tft.setTextSize(4);
		tft.print("Normal");
		
		tft.fillRect(x, y + MODE_BUTTON_Y + 5, MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR); 
		tft.drawRect(x, y + MODE_BUTTON_Y + 5, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[2][0] = x;
		modeSelectScreenBounds[2][1] = y + MODE_BUTTON_Y + 5;
		textInset = (MAIN_BUTTON_X - getPixelWidth("Engine", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[2][0] + textInset, modeSelectScreenBounds[2][1] + 24);
		tft.setTextColor(TEXT_COLOUR_1);
		tft.setTextSize(4);
		tft.print("Engine");
	}
	else if (currentUserMode == 2) {
		// Highlight Engine
		tft.fillRect(x, y - MODE_BUTTON_Y - 5, MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR); 
		tft.drawRect(x, y - MODE_BUTTON_Y - 5, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[0][0] = x;
		modeSelectScreenBounds[0][1] = y - MODE_BUTTON_Y - 5;
		int textInset = (MAIN_BUTTON_X - getPixelWidth("Beginner", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[0][0] + textInset, modeSelectScreenBounds[0][1] + 24);
		tft.setTextColor(TEXT_COLOUR_1);
		tft.setTextSize(4);
		tft.print("Beginner");
		
		tft.fillRect(x, y, MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR);
		tft.drawRect(x, y, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[1][0] = x;
		modeSelectScreenBounds[1][1] = y;
		textInset = (MAIN_BUTTON_X - getPixelWidth("Normal", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[1][0] + textInset, modeSelectScreenBounds[1][1] + 24);
		tft.setTextColor(TEXT_COLOUR_1);
		tft.setTextSize(4);
		tft.print("Normal");
		
		tft.fillRect(x, y + MODE_BUTTON_Y + 5, MODE_BUTTON_X, MODE_BUTTON_Y, HIGHLIGHT_COLOUR); 
		tft.drawRect(x, y + MODE_BUTTON_Y + 5, MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		modeSelectScreenBounds[2][0] = x;
		modeSelectScreenBounds[2][1] = y + MODE_BUTTON_Y + 5;
		textInset = (MAIN_BUTTON_X - getPixelWidth("Engine", 4)) / 2;
		tft.setCursor(modeSelectScreenBounds[2][0] + textInset, modeSelectScreenBounds[2][1] + 24);
		tft.setTextColor(TEXT_COLOUR_3);
		tft.setTextSize(4);
		tft.print("Engine");
	}
	time = millis();
}

void makeGameScreen() {
	tft.fillScreen(BACKGROUND_COLOUR);
	int padding = 5;
	int startY = 80;
	int x = tft.width() - GAME_BUTTON_X - padding;
	int y = startY;

	// Create buttons
	tft.fillRect(x, y, GAME_BUTTON_X, GAME_BUTTON_Y, PRIMARY_COLOUR);
	tft.drawRect(x, y, GAME_BUTTON_X, GAME_BUTTON_Y, BORDER_COLOUR);
	gameScreenBounds[0][0] = x;
	gameScreenBounds[0][1] = y;

	tft.fillRect(x, y + padding + GAME_BUTTON_Y, GAME_BUTTON_X, GAME_BUTTON_Y, SECONDARY_COLOUR);
	tft.drawRect(x, y + padding + GAME_BUTTON_Y, GAME_BUTTON_X, GAME_BUTTON_Y, BORDER_COLOUR);
	gameScreenBounds[1][0] = x;
	gameScreenBounds[1][1] = y + padding + GAME_BUTTON_Y;

	tft.fillRect(x, y + 2*padding + 2*GAME_BUTTON_Y, GAME_BUTTON_X, GAME_BUTTON_Y, TERTIARY_COLOUR);
	tft.drawRect(x, y + 2*padding + 2*GAME_BUTTON_Y, GAME_BUTTON_X, GAME_BUTTON_Y, BORDER_COLOUR);
	gameScreenBounds[2][0] = x;
	gameScreenBounds[2][1] = y + 2*padding + 2*GAME_BUTTON_Y;

	tft.fillRect(padding, startY, tft.width() - 3*padding - GAME_BUTTON_X, 3*GAME_BUTTON_Y + 2*padding, QUATERNARY_COLOUR);
	tft.drawRect(padding, startY, tft.width() - 3*padding - GAME_BUTTON_X, 3*GAME_BUTTON_Y + 2*padding, BORDER_COLOUR);
	
	// Add text to buttons
	int textInset = (GAME_BUTTON_X - getPixelWidth("Resign", 4)) / 2;
	tft.setCursor(gameScreenBounds[0][0] + textInset, gameScreenBounds[0][1] + 10);
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(4);
	tft.println("Resign");
	textInset = (GAME_BUTTON_X - getPixelWidth("(White)", 3)) / 2;
	tft.setTextSize(3);
	tft.setCursor(gameScreenBounds[0][0] + textInset, tft.getCursorY() + 3);
	tft.print("(White)");
	int endButton1Y = tft.getCursorY() + 3 + 3*8;

	textInset = (GAME_BUTTON_X - getPixelWidth("Draw", 4)) / 2;
	tft.setCursor(gameScreenBounds[1][0] + textInset, gameScreenBounds[1][1] + 25);
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(4);
	tft.print("Draw");

	textInset = (GAME_BUTTON_X - getPixelWidth("Resign", 4)) / 2;
	tft.setCursor(gameScreenBounds[2][0] + textInset, gameScreenBounds[2][1] + 10);
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(4);
	tft.println("Resign");
	textInset = (GAME_BUTTON_X - getPixelWidth("(Black)", 3)) / 2;
	tft.setTextSize(3);
	tft.setCursor(gameScreenBounds[0][0] + textInset, tft.getCursorY() + 3);
	tft.print("(Black)");

	tft.setTextColor(TEXT_COLOUR_2);
	tft.setTextSize(5);
	char* currModeStr = getUserModeStr(currentUserMode);
	char fullModeStr[strlen(currModeStr) + 6] = {};
	strcat(fullModeStr, currModeStr);
	strcat(fullModeStr, " Mode");
	textInset = ((tft.width() - 2*padding - THEME_BUTTON_X) - getPixelWidth(fullModeStr, 5)) / 2;
	tft.setCursor(padding + textInset, 20);
	tft.print(fullModeStr);
	
	int paddingY = 10;
	textInset = ((tft.width() - 3*padding - GAME_BUTTON_X) - getPixelWidth("Calculated", 3)) / 2;
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(3);
	tft.setCursor(padding + textInset, gameScreenBounds[0][1] + paddingY);
	tft.drawFastHLine(padding, gameScreenBounds[0][1] + GAME_BUTTON_Y - 1, tft.width() - 3*padding - GAME_BUTTON_X, BORDER_COLOUR); 
	tft.println("Calculated");
	textInset = ((tft.width() - 3*padding - GAME_BUTTON_X) - getPixelWidth("Engine Move", 3)) / 2;
	tft.setCursor(padding + textInset, tft.getCursorY() + 6);
	tft.println("Engine Move");

	if (currentUserMode == 2) {
		drawEngineMove(currentEngineMove);		
	}
	else {
		textInset = ((tft.width() - 3*padding - GAME_BUTTON_X) - getPixelWidth("N/A", 5)) / 2;
		int textInsetY = (tft.height() - (gameScreenBounds[0][1] + GAME_BUTTON_Y + padding) - 5*8) / 2;
		tft.setTextSize(5);
		tft.setTextColor(TEXT_COLOUR_1);
		tft.setCursor(padding + textInset, gameScreenBounds[0][1] + GAME_BUTTON_Y + textInsetY);
		tft.print("N/A");
	}
	
	makeThemeButton();
}

void makeEndScreen(char* msg) {
	tft.fillScreen(BACKGROUND_COLOUR);
	//resetState();
	int x = (tft.width() - OK_BUTTON_X) / 2;
	int y = 2 * tft.height() / 3;
	tft.fillRect(x, y, OK_BUTTON_X, OK_BUTTON_Y, PRIMARY_COLOUR);
	tft.drawRect(x, y, OK_BUTTON_X, OK_BUTTON_Y, BORDER_COLOUR);
	okButtonBounds[0][0] = x;
	okButtonBounds[0][1] = y;

	tft.setCursor(x + 15, y + 20);
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(6);
	tft.print("OK");

	// Split message into 2 lines for readability
	char* line2 = strstr(msg, "by ") + sizeof(char)*3;
	int ind = line2 - msg;
	char line1[ind];
	getSubstring(msg, line1, 0, ind);

	tft.setTextColor(TEXT_COLOUR_2);
	tft.setTextSize(5);

	x = (tft.width() - getPixelWidth(line1, 5)) / 2;
	tft.setCursor(x, TERMINATION_TEXT_Y);
	tft.println(line1);

	x = (tft.width() - getPixelWidth(line2, 5)) / 2;
	tft.setCursor(x, tft.getCursorY() + 5);
	tft.print(line2);
}

void makePromotionScreen() {
	currentScreen = 3;
	tft.fillScreen(BACKGROUND_COLOUR);

	int padding = 10;
	int marginY = tft.height() - 3*padding - 2*PROMOTION_Y;
	
	tft.setCursor(padding, padding + 6);
	tft.setTextColor(TEXT_COLOUR_2);
	tft.setTextSize(4);
	tft.println("Select a Piece for");
	tft.setCursor(padding, tft.getCursorY() + padding);
	tft.print("Pawn Promotion");
	
	int queenColour = SECONDARY_COLOUR;
	int rbColour = TERTIARY_COLOUR;
	int knightColour = PRIMARY_COLOUR;

	if (strcmp(currentTheme, "dark") == 0) {
		queenColour = TERTIARY_COLOUR;
		rbColour = SECONDARY_COLOUR;
		knightColour = PRIMARY_COLOUR;
	}

	//Queen
	tft.fillRect(padding, marginY + padding, PROMOTION_COMMON_X, PROMOTION_Y, queenColour);
	tft.drawRect(padding, marginY + padding, PROMOTION_COMMON_X, PROMOTION_Y, BORDER_COLOUR);
	promotionScreenBounds[0][0] = padding;
	promotionScreenBounds[0][1] = marginY + padding;
	tft.drawBitmap(promotionScreenBounds[0][0], promotionScreenBounds[0][1] + padding/2, epdBitmapQueen, ICON_SIZE, ICON_SIZE, BLACK);
	int textInset = (PROMOTION_COMMON_X - ICON_SIZE - getPixelWidth("Queen", 6)) / 2 - 20;
	tft.setCursor(promotionScreenBounds[0][0] + ICON_SIZE + textInset, promotionScreenBounds[0][1] + 28);
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(6);
	tft.print("Queen");
	
	//Rook
	tft.fillRect(PROMOTION_COMMON_X + 2*padding, marginY + padding, PROMOTION_RARE_X, PROMOTION_Y, rbColour);
	tft.drawRect(PROMOTION_COMMON_X + 2*padding, marginY + padding, PROMOTION_RARE_X, PROMOTION_Y, BORDER_COLOUR);
	promotionScreenBounds[1][0] = PROMOTION_COMMON_X + 2*padding;
	promotionScreenBounds[1][1] = marginY + padding;
	tft.drawBitmap(promotionScreenBounds[1][0], promotionScreenBounds[1][1], epdBitmapRook, ICON_SIZE, ICON_SIZE, BLACK);

	//Bishop
	tft.fillRect(padding, PROMOTION_Y + marginY + 2*padding, PROMOTION_RARE_X, PROMOTION_Y, rbColour);
	tft.drawRect(padding, PROMOTION_Y + marginY + 2*padding, PROMOTION_RARE_X, PROMOTION_Y, BORDER_COLOUR);
	promotionScreenBounds[2][0] = padding;
	promotionScreenBounds[2][1] = PROMOTION_Y + marginY + 2*padding;
	tft.drawBitmap(promotionScreenBounds[2][0], promotionScreenBounds[2][1] + padding/2, epdBitmapBishop, ICON_SIZE, ICON_SIZE, BLACK);
	
	//Knight
	tft.fillRect(PROMOTION_RARE_X + 2*padding, PROMOTION_Y + marginY + 2*padding, PROMOTION_COMMON_X, PROMOTION_Y, knightColour);
	tft.drawRect(PROMOTION_RARE_X + 2*padding, PROMOTION_Y + marginY + 2*padding, PROMOTION_COMMON_X, PROMOTION_Y, BORDER_COLOUR);
	promotionScreenBounds[3][0] = PROMOTION_RARE_X + 2*padding;
	promotionScreenBounds[3][1] = PROMOTION_Y + marginY + 2*padding;
	tft.drawBitmap(promotionScreenBounds[3][0], promotionScreenBounds[3][1], epdBitmapKnight, ICON_SIZE, ICON_SIZE, BLACK);
	textInset = (PROMOTION_COMMON_X - ICON_SIZE - getPixelWidth("Knight", 6)) / 2 - 10;
	tft.setCursor(promotionScreenBounds[3][0] + ICON_SIZE + textInset, promotionScreenBounds[3][1] + 28);
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(6);
	tft.print("Knight");
}

void makeThemeButton() {
	int padding = 5;
	tft.fillRect(tft.width() - padding - THEME_BUTTON_X, padding, THEME_BUTTON_X, THEME_BUTTON_Y, THEME_BUTTON_COLOUR);
	tft.drawRect(tft.width() - padding - THEME_BUTTON_X, padding, THEME_BUTTON_X, THEME_BUTTON_Y, BORDER_COLOUR);
	themeButtonBounds[0][0] = tft.width() - padding - THEME_BUTTON_X;
	themeButtonBounds[0][1] = padding;
	tft.drawBitmap(themeButtonBounds[0][0] + 5, themeButtonBounds[0][1] + 5, epdBitmapBrush, 60, 60, TEXT_COLOUR_1);
}

void makeConfirmationScreen(char piece) {
	selectedPromotion = piece;
	tft.fillScreen(BACKGROUND_COLOUR);
	int padding = 10;
	int x = (tft.width() - 2*YES_NO_X - padding) / 2;
	int y = 2 * tft.height() / 3;
	tft.fillRect(x, y, YES_NO_X, YES_NO_Y, PRIMARY_COLOUR);
	tft.drawRect(x, y, YES_NO_X, YES_NO_Y, BORDER_COLOUR);
	confirmationScreenBounds[0][0] = x;
	confirmationScreenBounds[0][1] = y;

	int textInset = (YES_NO_X - getPixelWidth("Yes", 5)) / 2;  
	tft.setCursor(x + textInset, y + 22);
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(5);
	tft.print("Yes");

	x += YES_NO_X + padding;
	tft.fillRect(x, y, YES_NO_X, YES_NO_Y, SECONDARY_COLOUR);
	tft.drawRect(x, y, YES_NO_X, YES_NO_Y, BORDER_COLOUR);
	confirmationScreenBounds[1][0] = x;
	confirmationScreenBounds[1][1] = y;

	textInset = (YES_NO_X - getPixelWidth("No", 5)) / 2;  
	tft.setCursor(x + textInset, y + 22);
	tft.setTextColor(TEXT_COLOUR_1);
	tft.setTextSize(5);
	tft.print("No");

	tft.setTextColor(TEXT_COLOUR_2);
	tft.setTextSize(5);

	x = (tft.width() - getPixelWidth("Promote to ", 5)) / 2;
	tft.setCursor(x, TERMINATION_TEXT_Y);
	tft.println("Promote to ");

	char confirmationText[10] = "a "; 
	if (piece == 'N') { 
		strcat(confirmationText, "Knight?");
	}
	else if (piece == 'R') { 
		strcat(confirmationText, "Rook?");
	}
	else if (piece == 'B') {
		strcat(confirmationText, "Bishop?");
	}

	x = (tft.width() - getPixelWidth(confirmationText, 5)) / 2;
	tft.setCursor(x, tft.getCursorY());
	tft.println(confirmationText);
  	time = millis();
}

void drawStartMode() {	
	char* tmp = getUserModeStr(currentUserMode);
	char mode[11] = {};
	if (strcmp(tmp, "Beginner") == 0) {
		strcat(mode, "(");
		strcat(mode, tmp);
		strcat(mode, ")");		
	}
	else {
		strcat(mode, " (");
		strcat(mode, tmp);
		strcat(mode, ") ");			
	}
	
	tft.setTextSize(3);
	tft.setTextColor(TEXT_COLOUR_1, SECONDARY_COLOUR);
	int textInset = (MAIN_BUTTON_X - getPixelWidth(mode, 3)) / 2 + 2;
	tft.setCursor(mainScreenBounds[0][0] + textInset, mainScreenBounds[0][1] + 160);
	tft.print(mode);
}

void drawEngineMove(char* move) {
	if (currentScreen == 2) {
		int padding = 5;
		tft.fillRect(padding, 80 + GAME_BUTTON_Y + padding, tft.width() - 3*padding - GAME_BUTTON_X - 1, 2*GAME_BUTTON_Y + padding, QUATERNARY_COLOUR);
		int textSize = getEngineMoveTextSize(move);	
		int textInset = ((tft.width() - 3*padding - GAME_BUTTON_X) - getPixelWidth(move, textSize)) / 2;
		int textHeight = textSize*8;
		int textInsetY = (tft.height() - (gameScreenBounds[0][1] + GAME_BUTTON_Y + padding) - textHeight) / 2;
		tft.setCursor(padding + textInset, gameScreenBounds[0][1] + GAME_BUTTON_Y + textInsetY);
		tft.setTextSize(textSize);
		tft.setTextColor(TEXT_COLOUR_1);
		tft.print(move);
	}
	strcpy(currentEngineMove, move);
}

void startGameButton() {
	updateState(currentFen, 's', getUserModeChar(currentUserMode));
	//updateState("8/4kN2/4N1Bq/1P1P1KP1/P5p1/2P1bR2/6p1/2r5 w - - 0 1", 's', getUserModeChar(currentUserMode));
	currentScreen = 2;
	makeGameScreen();
}

void selectModeButton() {
	makeModeSelectScreen();
	currentScreen = 1;
}

void beginnerModeButton(bool active) {
	if (active) {
		tft.fillRect(modeSelectScreenBounds[0][0], modeSelectScreenBounds[0][1], MODE_BUTTON_X, MODE_BUTTON_Y, HIGHLIGHT_COLOUR);
		tft.drawRect(modeSelectScreenBounds[0][0], modeSelectScreenBounds[0][1], MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		if (currentUserMode == 1) {
			normalModeButton(false);
		}
		else if (currentUserMode == 2) {
			engineModeButton(false);
		}
		currentUserMode = 0;
		drawStartMode();
		tft.setTextColor(TEXT_COLOUR_3);
	}
	else {
		tft.fillRect(modeSelectScreenBounds[0][0], modeSelectScreenBounds[0][1], MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR);
		tft.drawRect(modeSelectScreenBounds[0][0], modeSelectScreenBounds[0][1], MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		tft.setTextColor(TEXT_COLOUR_1);
	}
	int textInset = (MODE_BUTTON_X - getPixelWidth("Beginner", 4)) / 2;
	tft.setCursor(modeSelectScreenBounds[0][0] + textInset, modeSelectScreenBounds[0][1] + 24);
	tft.setTextSize(4);
	tft.print("Beginner");
}

void normalModeButton(bool active) {
	if (active) {
		tft.fillRect(modeSelectScreenBounds[1][0], modeSelectScreenBounds[1][1], MODE_BUTTON_X, MODE_BUTTON_Y, HIGHLIGHT_COLOUR);
		tft.drawRect(modeSelectScreenBounds[1][0], modeSelectScreenBounds[1][1], MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		if (currentUserMode == 0) {
			beginnerModeButton(false);
		}
		else if (currentUserMode == 2) {
			engineModeButton(false);
		}
		currentUserMode = 1;
		drawStartMode();
		tft.setTextColor(TEXT_COLOUR_3);
	}
	else {
		tft.fillRect(modeSelectScreenBounds[1][0], modeSelectScreenBounds[1][1], MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR);
		tft.drawRect(modeSelectScreenBounds[1][0], modeSelectScreenBounds[1][1], MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		tft.setTextColor(TEXT_COLOUR_1);
	}
	int textInset = (MODE_BUTTON_X - getPixelWidth("Normal", 4)) / 2;
	tft.setCursor(modeSelectScreenBounds[1][0] + textInset, modeSelectScreenBounds[1][1] + 24);
	tft.setTextSize(4);
	tft.print("Normal");
}

void engineModeButton(bool active) {
	if (active) {
		tft.fillRect(modeSelectScreenBounds[2][0], modeSelectScreenBounds[2][1], MODE_BUTTON_X, MODE_BUTTON_Y, HIGHLIGHT_COLOUR);
		tft.drawRect(modeSelectScreenBounds[2][0], modeSelectScreenBounds[2][1], MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		if (currentUserMode == 0) {
			beginnerModeButton(false);
		}
		else if (currentUserMode == 1) {
			normalModeButton(false);
		}
		currentUserMode = 2;
		drawStartMode();
		tft.setTextColor(TEXT_COLOUR_3);
	}
	else {
		tft.fillRect(modeSelectScreenBounds[2][0], modeSelectScreenBounds[2][1], MODE_BUTTON_X, MODE_BUTTON_Y, PRIMARY_COLOUR);
		tft.drawRect(modeSelectScreenBounds[2][0], modeSelectScreenBounds[2][1], MODE_BUTTON_X, MODE_BUTTON_Y, BORDER_COLOUR);
		tft.setTextColor(TEXT_COLOUR_1);
	}
	int textInset = (MODE_BUTTON_X - getPixelWidth("Engine", 4)) / 2;
	tft.setCursor(modeSelectScreenBounds[2][0] + textInset, modeSelectScreenBounds[2][1] + 24);
	tft.setTextSize(4);
	tft.print("Engine");
}

void resignWhiteButton() {
	updateState(currentFen, 'b', getUserModeChar(currentUserMode));
	currentScreen = 4;
	makeEndScreen("Black Wins by Resignation");
}

void resignBlackButton() {
	updateState(currentFen, 'w', getUserModeChar(currentUserMode));
	currentScreen = 4;
	makeEndScreen("White Wins by Resignation");
}

void drawButton() {
	updateState(currentFen, 'd', getUserModeChar(currentUserMode));
	currentScreen = 4;
	makeEndScreen("Game Drawn by Agreement");
}

void okButton() {
	currentScreen = 0;
	resetState();
	makeMainScreen();
}

void themeButton() {
	if (strcmp(currentTheme, "dark") == 0) {
		changeTheme("light");
	}
	else if (strcmp(currentTheme, "light") == 0) {
		changeTheme("dark");
	}
	refreshScreen();
}

void promotionButton(char piece) {
	//Change state of piece
	currentScreen = 2;
	makeGameScreen();
}

void checkmateWhite() {
	updateState(currentFen, 'w', getUserModeChar(currentUserMode));
	currentScreen = 4;
	makeEndScreen("White Wins by Checkmate");
}

void checkmateBlack() {
	updateState(currentFen, 'b', getUserModeChar(currentUserMode));
	currentScreen = 4;
	makeEndScreen("Black Wins by Checkmate");
}

void stalemate() {
	updateState(currentFen, 'd', getUserModeChar(currentUserMode));
	currentScreen = 4;
	makeEndScreen("Game Drawn by Stalemate");
}

void selectMode(int mode) {
	if (currentUserMode != mode) {
		if (mode == 0) {
			beginnerModeButton(true);
		}
		else if (mode == 1) {
			normalModeButton(true);
		}
		else if (mode == 2) {
			engineModeButton(true);
		}	
	}
}

void refreshScreen() {
	switch(currentScreen) {
		case 0: // Main Screen
			makeMainScreen();
			break;
		case 1: // Mode Select Screen
			makeMainScreen();
			makeModeSelectScreen();
			break;
		case 2: // Game Screen
			makeGameScreen();
			break;
	}
}

void updateState(char* FEN, char gameState, char userMode) {
	char stateData[100] = {};
	strncat(stateData, FEN, strlen(FEN));
	strncat(stateData, "@", 1);
	strncat(stateData, &gameState, 1);
	strncat(stateData, "@", 1);
	strncat(stateData, &userMode, 1);
	strncat(stateData, "\r", 1);

	strcpy(currentFen, FEN);
	currentGameState = gameState;
	currentUserMode = getUserModeInt(userMode);
	
	sendBluetoothData(stateData);
}

void resetState() {
	char* startingFen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
	updateState(startingFen, 'n', getUserModeChar(1)); 
	char* currentEngineMove = "N/A";
	char selectedPromotion = 'Q';
}

void sendBluetoothData(char* stateData) {
	int len = strlen(stateData);
	for (int i = 0; i < len; i++) {
		BTserial.write(stateData[i]);
	}
}

void parseWebPayload(char* webData) { //eg. "Nf3@w12@n" or "a@a@n" if not in engine mode
	char* engineMove = strtok(webData, "@"); //eg. Nf3
	char* webCode = strtok(NULL, "@"); //eg. 'w12', meaning white just moved, and the fullmove number is 12. Can only be 'w' (white), 'b' (black), or 'a' (filler) 
	char* gameState = strtok(NULL, "@"); //eg. 'c' checkmate, 's' stalemate', 'n' nothing

	char* turnColour;
	getSubstring(webCode, turnColour, 0, 1);
	char* moveNumStr;
	getSubstring(webCode, moveNumStr, 1, strlen(webCode));
	int moveNum = (atoi(moveNumStr) - 1) * 2;
	moveNum += (strcmp(turnColour, "b") == 0) ? 1 : 0;

	if (moveNum == 0) { // Starting position
		currentEngineMove = "N/A";
		return;
	}

	if (strcmp(gameState, "c") == 0) { // Checkmate
		if (strcmp(turnColour, "w") == 0) { // White win
			checkmateWhite();
		}
		else if (strcmp(turnColour, "b") == 0) {
			checkmateBlack();
		}
		return;
	}
	else if (strcmp(gameState, "s") == 0) { // Stalemate
		stalemate();
		return;
	}

	if (strcmp(engineMove, "a") == 0) { // Not in engine mode
		currentEngineMove = "N/A";
		return;
	}  

	if (moveNum == 0) {
		return;
	}

	if (strcmp(engineMove, currentEngineMove) != 0) { // Display engine move
		drawEngineMove(engineMove); 
	} 
}

void changeTheme(char *theme) {
	if (strcmp(theme, "light") == 0) {
		BACKGROUND_COLOUR = LIGHTBROWN;
		PRIMARY_COLOUR = TEAL;
		SECONDARY_COLOUR = GREEN;
		TERTIARY_COLOUR = PURPLE;
		QUATERNARY_COLOUR = DARKGRAY;
		BORDER_COLOUR = BLACK;
		TEXT_COLOUR_1 = WHITE;
		TEXT_COLOUR_2 = BLACK;
		TEXT_COLOUR_3 = BLACK;
		HIGHLIGHT_COLOUR = MUSTARD;
		THEME_BUTTON_COLOUR = PINK;
	}
	else if (strcmp(theme, "dark") == 0) {
		BACKGROUND_COLOUR = BLACK;
		PRIMARY_COLOUR = DARK_BLUEGRAY;
		SECONDARY_COLOUR = DARK_BROWN;
		TERTIARY_COLOUR = DARK_GREEN;
		QUATERNARY_COLOUR = DARK_PURPLE;
		BORDER_COLOUR = DARK_TAN;
		TEXT_COLOUR_1 = DARK_BROWNWHITE;
		TEXT_COLOUR_2 = DARK_TAN;
		TEXT_COLOUR_3 = BLACK;
		HIGHLIGHT_COLOUR = DARK_LIGHTBROWN;
		THEME_BUTTON_COLOUR = DARK_PINK;
	}
	currentTheme = theme;
}

char* getUserModeStr(int mode) {
	if (mode == 0) {
		return "Beginner";
	}
	else if (mode == 1) {
		return "Normal";
	}
	else if (mode == 2) {
		return "Engine";
	}
}

char getUserModeChar(int mode) {
	if (mode == 0) {
		return 'b';
	}
	else if (mode == 1) {
		return 'n';
	}
	else if (mode == 2) {
		return 'e';
	}
}

int getUserModeInt(char mode) {
	if (mode == 'b') {
		return 0;
	}
	else if (mode == 'n') {
		return 1;
	}
	else if (mode == 'e') {
		return 2;
	}	
}

int getPixelWidth(char* str, int textSize) {
	int strLen = strlen(str);
	int pixelSize = textSize * 6;
	int wordPixelWidth = strLen * pixelSize;
	return wordPixelWidth;
}

char* getSubstring(char* src, char* dest, int start, int end) {
	memcpy(dest, &src[start], end - start);
	dest[end - start - 1] = '\0';
	return dest;
}

int getEngineMoveTextSize(char* move) {
	int padding = 5;
	int boxWidth = tft.width() - 3*padding - GAME_BUTTON_X;
	int wordWidth, textSize;
	for (int i = 9; i > 0; i--) {
		wordWidth = getPixelWidth(move, i);
		textSize = i - 1;
		if (wordWidth < boxWidth) {
			break;
		}
	}
	return textSize;
}

//Start of integration functions
// ChessBoard Functions
void resetChessBoard()
{
    PieceType backRows[8] = {ROOK, KNIGHT, BISHOP, QUEEN, KING, BISHOP, KNIGHT, ROOK};
    int i, j;
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 8; j++)
        {
            currentBoard[i][j] = Square(i,j);
            oldBoard[i][j] = Square(i,j);
            Colour col;
            PieceType type;
            if (i > 1 && i < 6)
            {
                currentBoard[i][j].piece = Piece();
                oldBoard[i][j].piece = Piece();
                continue;
            }
            else if (i < 2)
            {
                col = WHITE;
                if (i == 0)
                    type = backRows[j];
                else
                    type = PAWN;
            }
            else
            {
                col = BLACK;
                if (i == 7)
                    type = backRows[j];
                else
                    type = PAWN;
            }
            currentBoard[i][j].piece = Piece(type, col);
            oldBoard[i][j].piece = Piece(type, col);
        }
    }    
}

bool movePiece(int* fromSquare, int* toSquare, PieceType promotionType = NO_PIECE)
{
    int fromRow = fromSquare[0];
    int fromCol = fromSquare[1];
    int toRow = toSquare[0];
    int toCol = toSquare[1];

    Piece &fromPiece = currentBoard[fromRow][fromCol].piece;
    Piece &toPiece = currentBoard[toRow][toCol].piece;

    if (fromPiece.type == NO_PIECE)
    {
        return false;
    }
    if (toPiece.type != NO_PIECE && fromPiece.colour == toPiece.colour)
    {
        // Cannot capture own piece
        // illegalMove(int fromRow, int fromCol, int toRow, int toCol);
        return false;
    }
    else if (toPiece.type != NO_PIECE && fromPiece.colour != toPiece.colour)
    {
    }
    switch (fromPiece.type)
    {
    case PAWN:
        if (fromPiece.colour == 0)
        { // white pawn
            if (fromRow == 1 && toRow == 3 && fromCol == toCol && toPiece.type == NO_PIECE)
            {
                // White pawn can move two squares from the second row
                toPiece = fromPiece;
                fromPiece = Piece{};
                break;
            }
            if (fromRow + 1 == toRow && fromCol == toCol && toPiece.type == NO_PIECE)
            {
                // White pawn can move one square forward
                toPiece = fromPiece;
                fromPiece = Piece{};
                break;
            }
            if (fromRow + 1 == toRow && abs(fromCol - toCol) == 1 && toPiece.type != NO_PIECE)
            {
                // White pawn can capture diagonally
                toPiece = fromPiece;
                fromPiece = Piece{};
                break;
            }
            if (fromRow == 4 && toRow == 5 && abs(fromCol - toCol) == 1 && toPiece.type == NO_PIECE)
            {
                // White pawn can capture en passant
                currentBoard[toRow - 1][toCol].piece.type = NO_PIECE;
                toPiece = fromPiece;
                fromPiece = Piece{};
                break;
            }
        }
        else
        { // black pawn
            if (fromRow == 6 && toRow == 4 && fromCol == toCol && toPiece.type == NO_PIECE)
            {
                // Black pawn can move two squares from the seventh row
                toPiece = fromPiece;
                fromPiece = Piece{};
                break;
            }
            if (fromRow - 1 == toRow && fromCol == toCol && toPiece.type == NO_PIECE)
            {
                // Black pawn can move one square forward
                toPiece = fromPiece;
                fromPiece = Piece{};
                break;
            }
            if (fromRow - 1 == toRow && abs(fromCol - toCol) == 1 && toPiece.type != NO_PIECE)
            {
                // Black pawn can capture diagonally
                toPiece = fromPiece;
                fromPiece = Piece{};
                break;
            }
            if (fromRow == 3 && toRow == 2 && abs(fromCol - toCol) == 1 && toPiece.type == NO_PIECE)
            {
                // Black pawn can capture en passant
                currentBoard[toRow + 1][toCol].piece.type = NO_PIECE;
                toPiece = fromPiece;
                fromPiece = Piece{};
                break;
            }
        }
        if (toRow == 0 || toRow == 7)
        {
            // Pawn has reached the other side of the board, promote it
            toPiece = (Piece){promotionType, fromPiece.colour};
            fromPiece = Piece{};
            break;
        }
        // Invalid move for pawn
        return false;
    case KNIGHT:
        if (abs(fromRow - toRow) == 2 && abs(fromCol - toCol) == 1)
        {
            // Knight can move in an L shape
            toPiece = fromPiece;
            fromPiece = Piece{};
            break;
        }
        if (abs(fromRow - toRow) == 1 && abs(fromCol - toCol) == 2)
        {
            // Knight can move in an L shape
            toPiece = fromPiece;
            fromPiece = Piece{};
            break;
        }
        // Invalid move for knight
        return false;
    case BISHOP:
        if (abs(fromRow - toRow) == abs(fromCol - toCol))
        {
            // Bishop can move diagonally
            toPiece = fromPiece;
            fromPiece = Piece{};
            break;
        }
        // Invalid move for bishop
        return false;
    case ROOK:
        if (fromRow == toRow || fromCol == toCol)
        {
            // Rook can move horizontally or vertically
            toPiece = fromPiece;
            fromPiece = Piece{};
            break;
        }
        // Invalid move for rook
        return false;
    case QUEEN:
        if (fromRow == toRow || fromCol == toCol || abs(fromRow - toRow) == abs(fromCol - toCol))
        {
            // Queen can move horizontally, vertically, or diagonally
            toPiece = fromPiece;
            fromPiece = Piece{};
            break;
        }
        // Invalid move for queen
        return false;
    case KING:
        if (abs(fromRow - toRow) <= 1 && abs(fromCol - toCol) <= 1)
        {
            // King can move one square in any direction
            toPiece = fromPiece;
            fromPiece = Piece{};
            break;
        }
        if (fromRow == 0 && fromCol == 4 && toRow == 0 && toCol == 6)
        {
            // White kingside castle
            if (currentBoard[0][5].piece.type == NO_PIECE && currentBoard[0][6].piece.type == NO_PIECE && currentBoard[0][7].piece.type == ROOK)
            {
                currentBoard[0][6].piece = currentBoard[0][4].piece;
                currentBoard[0][4].piece = Piece{};
                currentBoard[0][5].piece = currentBoard[0][7].piece;
                currentBoard[0][7].piece = Piece{};
                break;
            }
        }
        if (fromRow == 0 && fromCol == 4 && toRow == 0 && toCol == 2)
        {
            // White queenside castle
            if (currentBoard[0][1].piece.type == NO_PIECE && currentBoard[0][2].piece.type == NO_PIECE && currentBoard[0][3].piece.type == NO_PIECE && currentBoard[0][0].piece.type == ROOK)
            {
                currentBoard[0][2].piece = currentBoard[0][4].piece;
                currentBoard[0][4].piece = Piece{};
                currentBoard[0][3].piece = currentBoard[0][0].piece;
                currentBoard[0][0].piece = Piece{};
                break;
            }
        }
        if (fromRow == 7 && fromCol == 4 && toRow == 7 && toCol == 6)
        {
            // Black kingside castle
            if (currentBoard[7][5].piece.type == NO_PIECE && currentBoard[7][6].piece.type == NO_PIECE && currentBoard[7][7].piece.type == ROOK)
            {
                currentBoard[7][6].piece = currentBoard[7][4].piece;
                currentBoard[7][4].piece = Piece{};
                currentBoard[7][5].piece = currentBoard[7][7].piece;
                currentBoard[7][7].piece = Piece{};
                break;
            }
        }
        if (fromRow == 7 && fromCol == 4 && toRow == 7 && toCol == 2)
        {
            // Black queenside castle
            if (currentBoard[7][1].piece.type == NO_PIECE && currentBoard[7][2].piece.type == NO_PIECE && currentBoard[7][3].piece.type == NO_PIECE && currentBoard[7][0].piece.type == ROOK)
            {
                currentBoard[7][2].piece = currentBoard[7][4].piece;
                currentBoard[7][4].piece = Piece{};
                currentBoard[7][3].piece = currentBoard[7][0].piece;
                currentBoard[7][0].piece = Piece{};
                break;
            }
        }
        // Invalid move for king
        return false;
    }
    return true;
}

// Converts a single row of the chess board to a FEN string
void rowToFen(Square row[8], int &fen_index)
{
    int empty_count = 0;
    for (int i = 0; i < 8; ++i)
    {
        Piece piece = row[i].piece;
        if (piece.type == PieceType::NO_PIECE)
        {
            ++empty_count;
        }
        else
        {
            if (empty_count > 0)
            {
                FEN[fen_index++] = (char)('0' + empty_count);
                empty_count = 0;
            }
            FEN[fen_index++] = pieceToChar(piece);
        }
    }
    if (empty_count > 0)
    {
        FEN[fen_index++] = '0' + empty_count;
    }
}

// Converts a chess board to a FEN string
void boardToFen()
{
    int fen_index = 0;
    for (int i = 0; i < 8; ++i)
    {
        rowToFen(currentBoard[i], fen_index);
        if (i != 7)
            FEN[fen_index++] = '/';
        else
            FEN[fen_index++] = ' ';
    }

    // w or b
    FEN[fen_index++] = whoseTurn == WHITE ? 'w' : 'b';
    FEN[fen_index++] = ' ';

    int castle_index = 0;
    while (CastlingStatus[castle_index])
    {
        FEN[fen_index++] = CastlingStatus[castle_index++];
    }

    // en passant status. leave as - for now
    FEN[fen_index++] = '-';
    FEN[fen_index++] = ' ';

    // convert turn number to chars
    int temp = turns;
    char buf[6];
    int buf_index = 0;
    buf[buf_index] = '\0';
    while (temp > 0)
    {
        buf[++buf_index] = '0' + (temp % 10);
        temp /= 10;
    }
    while (buf[buf_index])
    {
        FEN[fen_index++] = buf[buf_index--];
    }
    
    FEN[fen_index++] = ' ';

    FEN[fen_index++] = '\r';
    FEN[fen_index] = '\0';
}

int readHall(int adcnum, int rx, int tx)
{
    digitalWrite(cs, HIGH);
    digitalWrite(clk, LOW);
    digitalWrite(cs, LOW);

    int commandout = adcnum;
    commandout |= 0x18;
    commandout <<= 3;

    for (int i = 0; i < 5; i++)
    {
        if (commandout & 0x80)
        {
            digitalWrite(tx, HIGH);
        }
        else
        {
            digitalWrite(tx, LOW);
        }

        commandout <<= 1;
        digitalWrite(clk, HIGH);
        digitalWrite(clk, LOW);
    }

    int adcout = 0;

    for (int i = 0; i < 12; i++)
    {
        digitalWrite(clk, HIGH);
        digitalWrite(clk, LOW);

        adcout <<= 1;

        if (digitalRead(rx))
            adcout |= 0x1;
    }

    digitalWrite(cs, HIGH);

    adcout >>= 1;
    return adcout;
}

void readHallRow(int row, int rx, int tx)
{
    for (int i = 0; i < 8; i++)
    {
        rawStates[row][i] = readHall(i, rx, tx);
    }
}

void readHallSensors()
{
    for (int i = 0; i < 8; i++)
    {
        readHallRow(i, hallRx[i], hallTx[i]);
    }

    printHall();
    Serial.print("\n");
}

void printHall()
{
    int i, j;

    Serial.println("\ta\tb\tc\td\te\tf\tg\th");
    for (i = 0; i < 8; i++)
    {
        Serial.print(8 - i);
        Serial.print("\t");
        for (j = 0; j < 8; j++)
        {
            Serial.print(rawStates[i][j]);
            Serial.print("\t");
        }
        Serial.print("\n");
        delay(1);
    }
}

void setupLEDs()
{
    for (int i = 0; i < 9; i++)
    {
        pinMode(anodes[i], OUTPUT);
        pinMode(cathodes[i], OUTPUT);
        digitalWrite(anodes[i], HIGH);
        digitalWrite(cathodes[i], LOW);
    }
}

void setupHallSensors()
{
    pinMode(cs, OUTPUT);
    pinMode(clk, OUTPUT);

    for (int i = 0; i < 8; i++)
    {
        pinMode(hallRx[i], INPUT);
        pinMode(hallTx[i], OUTPUT);
    }
}

// PieceIdentification Functions
char pieceToChar(Piece piece)
{
    if (piece.colour == NO_COLOUR)
    {
        return '0';
    }
    
    return (char)(piece.type + piece.colour);
}

Piece charToPiece(char pieceChar)
{
    if ((int)pieceChar > 90)
    {
        // if char is lowercase
        return Piece{(PieceType)pieceChar, BLACK};
    }
    else
    {
        // if char is uppercase
        return Piece{(PieceType)pieceChar, WHITE};
    }
}

void printBoard()
{
    int i, j;

    Serial.println("\ta\tb\tc\td\te\tf\tg\th");
    for (i = 0; i < 8; i++)
    {
        Serial.print(8 - i);
        Serial.print("\t");
        for (j = 0; j < 8; j++)
        {
            Serial.print(pieceToChar(currentBoard[i][j].piece));
            Serial.print("\t");
        }
        Serial.print("\n");
    }
}

// 0 is when the game is over and before the game is started.
// Enters state when powered on and when game over button is pressed
// Leaves state when all whites and blacks are in correct spot and the game start is pressed

// 1 Game is active and players are thinking (all pieces are on the board)
// Enters state when game start is pressed
// Leaves state when a piece is picked up or if resign or draw is pressed

// 2 Piece is picked up, LEDs are lit up accordingly
// Keeps track of what piece was picked up and what are the possible moves
// Enters state when piece is picked up
// Leaves state when the piece is placed again


bool gameStartValid() //Given white starting on one side, checks if the board state is the starting position
{
    bool valid = true;
    int i;
    if (currentBoard[0][0].piece.colour == WHITE)
    {
        for (i = 0; i < 8; i++)
        {
            if (currentBoard[0][i].piece.colour != WHITE)
                valid = false;
            if (currentBoard[1][i].piece.colour != WHITE)
                valid = false;

            if (currentBoard[6][i].piece.colour != BLACK)
                valid = false;
            if (currentBoard[7][i].piece.colour != BLACK)
                valid = false;
        }
    }
    else
    {
        for (i = 0; i < 8; i++)
        {
            if (currentBoard[0][i].piece.colour != BLACK)
                valid = false;
            if (currentBoard[1][i].piece.colour != BLACK)
                valid = false;

            if (currentBoard[6][i].piece.colour != WHITE)
                valid = false;
            if (currentBoard[7][i].piece.colour != WHITE)
                valid = false;
        }
    }
    
    
    return valid;
}

void identifyColors()
{
    int i, j;
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 8; j++)
        {
            if (rawStates[i][j] < WHITE_HALL)
                currentBoard[i][j].piece.colour = WHITE;
            else if (rawStates[i][j] > BLACK_HALL)
                currentBoard[i][j].piece.colour = BLACK;
            else
                currentBoard[i][j].piece.colour = NO_COLOUR;
        }
    }
}

void updateBoard()
{
    int i, j;
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 8; j++)
        {
            oldBoard[i][j] = currentBoard[i][j];
        }
    }
}

bool checkPick()
{
    bool change = false;
    int i, j;
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 8; j++)
        {
            if (currentBoard[i][j].piece.colour != oldBoard[i][j].piece.colour)
            {
                liftedSquare = &currentBoard[i][j];
                change = true;
            }
        }
    }
    return change;
}

bool checkPlace()
{
    bool change = false;
    int i, j;
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 8; j++)
        {
            if (currentBoard[i][j].piece.colour != oldBoard[i][j].piece.colour)
            {
                currentBoard[i][j] = *liftedSquare;
                (*liftedSquare).piece = Piece();
                change = true;
            }
        }
    }
    return change;
}

void lightUp(int row, int col)
{
    digitalWrite(anodes[row], LOW);
    digitalWrite(anodes[row + 1], LOW);
    digitalWrite(cathodes[col], HIGH);
    digitalWrite(cathodes[col + 1], HIGH);
}

// return true to continue checking for suqares to light
// return false to stop checking (for pieces that move in straight lines)
bool lightValidSquare(int row, int col, Colour activeColour)
{
    if (currentBoard[row][col].piece.type == NO_PIECE)
    {
        lightUp(row, col);
        return true;
    }
    else if (currentBoard[row][col].piece.colour != activeColour)
    {
        lightUp(row, col);
        return false;
    }
    else
    {
        return false;
    }
}

void lightsOff()
{
    int m;
    for (m = 0; m < 9; m++)
    {
        digitalWrite(anodes[m], HIGH);
        digitalWrite(cathodes[m], LOW);
    }
}

void highlightPawnMoves(Square square)
{
    int row = square.row;
    int col = square.col;
    Colour activeColour = square.piece.colour;

    int direction = activeColour == WHITE ? 1 : -1;

    if (row + direction >= 0 && row + direction <= 7)
    {
        // Pawn can move forward by one square
        if (currentBoard[row + direction][col].piece.type == NO_PIECE)
        {
            lightUp(row + direction, col);
        }

        // Pawn can capture enemy piece diagonally
        if (col > 0 && currentBoard[row + direction][col - 1].piece.colour != activeColour)
        {
            lightUp(row + direction, col - 1);
        }
        if (col < 7 && currentBoard[row + direction][col + 1].piece.colour != activeColour)
        {
            lightUp(row + direction, col + 1);
        }
    }
}

void highlightKnightMoves(Square square)
{
    int row = square.row;
    int col = square.col;
    Colour activeColour = square.piece.colour;

    int moves[8][2] = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};
    for (int i = 0; i < 8; i++)
    {
        int newRow = row + moves[i][0];
        int newCol = col + moves[i][1];
        if (newRow >= 0 && newRow <= 7 && newCol >= 0 && newCol <= 7)
        {
            Piece targetPiece = currentBoard[newRow][newCol].piece;
            if (targetPiece.colour != activeColour)
            {
                lightUp(newRow, newCol);
            }
        }
    }
}

void highlightBishopMoves(Square square)
{
    int row = square.row;
    int col = square.col;
    Colour activeColour = square.piece.colour;

    // maximum possible distances from piece to edge of board
    // ul = up left, dr = down right, etc.
    int dist_ul = min(7-row, col);
    int dist_ur = min(7-row, 7-col);
    int dist_dl = min(row, col);
    int dist_dr = min(row, 7-col);

    // Move up left
    for (int i = 1; i <= dist_ul; i++)
    {
        if (!lightValidSquare(row+i, col-i, activeColour))
        {
            break;
        }
    }

    // Move up right
    for (int i = 1; i <= dist_ur; i++)
    {
        if (!lightValidSquare(row+i, col+i, activeColour))
        {
            break;
        }
    }

    // Move down left
    for (int i = 1; i <= dist_dl; i++)
    {
        if (!lightValidSquare(row-i, col-i, activeColour))
        {
            break;
        }
    }

    // Move down right
    for (int i = 1; i <= dist_dr; i++)
    {
        if (!lightValidSquare(row-i, col+i, activeColour))
        {
            break;
        }
    }
}

void highlightRookMoves(Square square)
{
    int row = square.row;
    int col = square.col;
    Colour activeColour = square.piece.colour;

    // Check moves to the right
    for (int i = col + 1; i = 7; i++)
    {
        if (!lightValidSquare(row, i, activeColour))
        {
            break;
        }
    }

    // Check moves to the left
    for (int i = col - 1; i >= 0; i--)
    {
        if (!lightValidSquare(row, i, activeColour))
        {
            break;
        }
    }

    // Check moves down
    for (int i = row - 1; i >= 0; i--)
    {
        if (!lightValidSquare(i, col, activeColour))
        {
            break;
        }
    }

    // Check moves up
    for (int i = row + 1; i <= 7; i++)
    {
        if (!lightValidSquare(i, col, activeColour))
        {
            break;
        }
    }
}

void highlightQueenMoves(Square square)
{
    int row = square.row;
    int col = square.col;
    Colour activeColour = square.piece.colour;

    // maximum possible distances from piece to edge of board
    // ul = up left, dr = down right, etc.
    int dist_ul = min(7-row, col);
    int dist_ur = min(7-row, 7-col);
    int dist_dl = min(row, col);
    int dist_dr = min(row, 7-col);

    // Move up left
    for (int i = 1; i <= dist_ul; i++)
    {
        if (!lightValidSquare(row+i, col-i, activeColour))
        {
            break;
        }
    }

    // Move up right
    for (int i = 1; i <= dist_ur; i++)
    {
        if (!lightValidSquare(row+i, col+i, activeColour))
        {
            break;
        }
    }

    // Move down left
    for (int i = 1; i <= dist_dl; i++)
    {
        if (!lightValidSquare(row-i, col-i, activeColour))
        {
            break;
        }
    }

    // Move down right
    for (int i = 1; i <= dist_dr; i++)
    {
        if (!lightValidSquare(row-i, col+i, activeColour))
        {
            break;
        }
    }

    // Move down
    for (int i = row - 1; i >= 0; i--)
    {
        if (!lightValidSquare(i, col, activeColour))
        {
            break;
        }
    }

    // Move up
    for (int i = row + 1; i <= 7; i++)
    {
        if (!lightValidSquare(i, col, activeColour))
        {
            break;
        }
    }

    // Move left
    for (int i = col - 1; i >= 0; i--)
    {
        if (!lightValidSquare(row, i, activeColour))
        {
            break;
        }
    }

    // Move right
    for (int i = col + 1; i <= 7; i++)
    {
        if (!lightValidSquare(row, i, activeColour))
        {
            break;
        }
    }
}

void highlightKingMoves(Square square)
{
    int row = liftedSquare->row;
    int col = liftedSquare->col;
    Colour activeColour = liftedSquare->piece.colour;

    // Check the squares directly adjacent to the king
    if (row > 0)
    {
        if (currentBoard[row - 1][col].piece.colour != activeColour)
        {
            lightUp(row - 1, col);
        }
        if (col > 0 && currentBoard[row - 1][col - 1].piece.colour != activeColour)
        {
            lightUp(row - 1, col - 1);
        }
        if (col < 7 && currentBoard[row - 1][col + 1].piece.colour != activeColour)
        {
            lightUp(row - 1, col + 1);
        }
    }
    if (row < 7)
    {
        if (currentBoard[row + 1][col].piece.colour != activeColour)
        {
            lightUp(row + 1, col);
        }
        if (col > 0 && currentBoard[row + 1][col - 1].piece.colour != activeColour)
        {
            lightUp(row + 1, col - 1);
        }
        if (col < 7 && currentBoard[row + 1][col + 1].piece.colour != activeColour)
        {
            lightUp(row + 1, col + 1);
        }
    }
    if (col > 0 && currentBoard[row][col - 1].piece.colour != activeColour)
    {
        lightUp(row, col - 1);
    }
    if (col < 7 && currentBoard[row][col + 1].piece.colour != activeColour)
    {
        lightUp(row, col + 1);
    }
}

void flash()
{
    Square square = *liftedSquare;
    switch (square.piece.type)
    {
    case PAWN:
        highlightPawnMoves(square);
        return;
    case KNIGHT:
        highlightKnightMoves(square);
        return;
    case ROOK:
        highlightRookMoves(square);
        return;
    case BISHOP:
        highlightBishopMoves(square);
        return;
    case QUEEN:
        highlightQueenMoves(square);
        return;
    case KING:
        highlightKingMoves(square);
        return;
    }
}

void setup()
{
    setupHallSensors();
    setupLEDs();

    Serial.begin(9600);
}

void loop()
{
    if (gameCommand == 'e') //END_GAME
    {
        gameState = INIT_GAME;
    }
    

    readHallSensors();

    identifyColors();

    Serial.print((char)gameState);
    Serial.print("\t");
    Serial.print(turns);
    Serial.print("\t");
    //Serial.println((char)gameCommand);
    Serial.print("\n");

    switch (gameState)
    {
    case INIT_GAME:
        resetChessBoard();
        // wait for game mode selection from LCD screen
        // if (Serial1.available() > 0)
        // {
        //     int temp = Serial1.read();
        //     if (temp == BEGINNER_MODE || temp == NORMAL_MODE || temp == ENGINE_MODE)
        //     {
        //         gameMode = (GameMode)temp;
        //         gameState = PLAY_GAME;
        //     }
        // }
        gameState = PLAY_GAME;
        break;
    case PLAY_GAME:
        if (gameStartValid()) 
        {
            gameState = WAIT_PICK; //Not always picking up pieces in beginner mode
        }
        else
        {
            // figure out some way to indicate that the game isn't set up properly.
            // light squares??
        }
        break;
    case RESET_GAME:
        // do we need this state?
        break;
    case WAIT_PICK:
        // sendFen();
        if (checkPick())
        {
            gameState = PIECE_LIFTED;
        }
        break;
    case PIECE_LIFTED:
        // sendFen();
        flash();
        if (checkPlace())
        {
            gameState = VALID_MOVE;
            // if (movePiece(liftedSquare, placedSquare, QUEEN))
            // {
            //     gameState = VALID_MOVE;
            // }
            // else
            // {
            //     gameState = INVALID_MOVE;
            // }
        }
        break;
    case REMOVE_PIECE:
        // should we keep track of pieces taken?
        gameState = WAIT_PICK;
        break;
    case PROMOTING:
        // wait for piece selection from LCD screen
        if (promoting)
        {
            if (checkPick())
            {
                gameState = PIECE_LIFTED;
            }
        }
        
        gameState = WAIT_PICK;
        break;
    case VALID_MOVE:
        if (whoseTurn == WHITE)
            whoseTurn = BLACK;
        else
        {
            whoseTurn = WHITE;
            turns += 1;
        }
        lightsOff();
        gameState = WAIT_PICK;
        break;
    case INVALID_MOVE:
        lightUp((*liftedSquare).row, (*liftedSquare).col);
        gameState = WAIT_PICK;
        break;
    default:
        break;
    }

    // printHall();
    // delay(delay_const);
    // Serial.print("\n");
    // Serial.print("\n");
    // printColors();
    // delay(delay_const);
    // Serial.print("\n");
    // Serial.print("\n");
    Serial.println(FEN);
    printBoard();
    delay(delay_const);
    Serial.print("\n");

    updateBoard();
    delay(delay_const);
}